{"/develop/en/plugins.html": {"title": "teedoc plugin development", "content": "teedoc plugin development\n===========\n\nThe plug-in development of `teedoc` is very simple. At present, you only need to modify the template according to the template to realize the new function. If you know about `python` `html` `css` `js`, it will be easier.\n\nThe operating principle of the plugin is that `teedoc` provides [plugin API](https://github.com/teedoc/teedoc/blob/main/teedoc/plugin.py), write a `python` package, inherit this class, and rewrite The required method (`API`) is fine, the specific meaning of each method is detailed in the [plugin API](https://github.com/teedoc/teedoc/blob/main/teedoc/plugin.py) file Annotation\n\n> If you find that the API is unreasonable, you can [submit issue](https://github.com/teedoc/teedoc/issues) to initiate a discussion and improve together~\n\n\n## Reference template\n\nYou can refer to [default plugin](https://github.com/teedoc/teedoc/tree/main/plugins)\n\n\n## Plug-in directory structure\n\nHere is [teedoc-plugin-baidu-tongji](https://github.com/teedoc/teedoc/tree/main/plugins/teedoc-plugin-baidu-tongji) as an example\n\n* Create a directory, the directory name is the same as the plug-in name, it is recommended to start with `teedoc-plugin-` for easy search\n* Then create a `setup.py` file, this is the general configuration file of the `python` package, the most important thing in the file is to execute the `setuptools.setup()` function, the parameters mainly include the following several, more can be `python` official document search\n\n```python\nsetup(\n    name='teedoc-plugin-baidu-tongji',\n    version=\"1.0.2\",\n    author='Neucrack',\n    author_email='xxx@xxx.com',\n    description='baidu tongji plugin for teedoc',\n    long_description=long_description, # can read from README.md\n    long_description_content_type=\"text/markdown\",\n    url='https://github.com/Neutree/teedoc',\n    license='MIT',\n    # See https://pypi.python.org/pypi?%3Aaction=list_classifiers\n    classifiers=[\n\n        # Indicate who your project is intended for\n        'Intended Audience :: Developers',\n\n        # Pick your license as you wish (should match \"license\" above)\n        'License :: OSI Approved :: MIT License',\n\n        # Specify the Python versions you support here. In particular, ensure\n        # that you indicate whether you support Python 2, Python 3 or both.\n        'Programming Language :: Python :: 3'\n    ],\n\n    keywords='teedoc baidu tongji',\n\n    # List run-time dependencies here. These will be installed by pip when\n    # your project is installed. For an analysis of \"install_requires\" vs pip's\n    # requirements files see:\n    # https://packaging.python.org/en/latest/requirements.html\n    install_requires=install_requires,\n\n    # List additional groups of dependencies here (e.g. development\n    # dependencies). You can install these using the following syntax,\n    # for example:\n    # $ pip install -e .[dev,test]\n    extras_require={\n        #'dev': ['check-manifest'],\n        #'test': ['coverage'],\n    },\n\n    # You can just specify the packages manually here if your project is\n    # simple. Or you can use find_packages().\n    packages=packages,\n\n    # If there are data files included in your packages that need to be\n    # installed, specify them here. If using Python 2.6 or less, then these\n    # have to be included in MANIFEST.in as well.\n    package_data={\n        \"teedoc_plugin_baidu_tongji\": ['assets/*'],\n    },\n\n    # Although'package_data' is the preferred approach, in some case you may\n    # need to place data files outside of your packages. See:\n    # http://docs.python.org/3.4/distutils/setupscript.html#installing-additional-files # noqa\n    # In this case,'data_file' will be installed into'<sys.prefix>/my_data'\n    data_files=[\n        ],\n\n    # To provide executable scripts, use entry points in preference to the\n    # \"scripts\" keyword. Entry points provide cross-platform support and allow\n    # pip to create the appropriate form of executable for the target platform.\n    entry_points={\n        #'console_scripts': [\n        # #'gui_scripts': [\n        #'teedoc=teedoc-plugin-markdown-parser.main:main',\n        # ],\n    },\n)\n```\n\n* Create package\n\nYou need to create another subfolder to store the source code. The file name is just to replace the minus sign `-` in the project name with an underscore `_`, because the package name in the `python` code requires that the minus sign cannot be used, for example, here is `teedoc_plugin_baidu_tongji`\n\nThen create a new file `__init__.py`\n\n* Edit `__init__.py`\n\nTo realize the function of Baidu statistics, it is actually necessary to add a script specified by Baidu statistics to the `<head></head>` tags of all pages, that is, the `<script></script>` tag. At the same time, from the document Get the statistical number (`code`) in the configuration, the code is as follows:\n\n```python\nimport os, sys\nfrom teedoc import Plugin_Base\nfrom teedoc import Fake_Logger\n\n\n\nclass Plugin(Plugin_Base):\n    name = \"teedoc-plugin-baidu-tongji\"\n    desc = \"baidu tongji support for teedoc\"\n    defautl_config = {\n    }\n\n    def on_init(self, config, doc_src_path, site_config, logger = None):\n        '''\n            @config a dict object\n            @logger teedoc.logger.Logger object\n        '''\n        self.logger = Fake_Logger() if not logger else logger\n        self.doc_src_path = doc_src_path\n        self.site_config = site_config\n        self.config = Plugin.defautl_config\n        self.config.update(config)\n        self.logger.i(\"-- plugin <{}> init\".format(self.name))\n        self.logger.i(\"-- plugin <{}> config: {}\".format(self.name, self.config))\n        \n        # set site_root_url env value\n        if not \"code\" in config:\n            self.logger.e('can not find config[\"code\"] in plugin {}'.format(self.name))\n            return\n        baidu_tongji_code ='''<script>\nvar _hmt = _hmt || [];\n(function() {{\n  var hm = document.createElement(\"script\");\n  hm.src = \"https://hm.baidu.com/hm.js?{}\";\n  var s = document.getElementsByTagName(\"script\")[0];\n  s.parentNode.insertBefore(hm, s);\n}})();\n</script>'''.format(config[\"code\"])\n        self.html_header_items = [baidu_tongji_code]\n\n\n    def on_add_html_header_items(self):\n        return self.html_header_items\n```\n\nYou can see that `class Plugin(Plugin_Base):` inherits the `Plugin_Base` class, and then rewrites the `on_init` and `on_add_html_header_items` methods. When the document is built by `teedoc`, these two functions will be called at the right time.\n\nWe obtained the Baidu statistics of the `code` from the `config` in the `on_init` initialization function, then generated the content of the `<script>` tag and stored it in the `html_header_items`, and then returned it in the `on_add_html_header_items` function , So that `teedoc` will add this tag to the `<head>` tag of all `HTML` pages\n\n* resource\n\nCan be in `setup.py`\n```python\n    package_data={\n        \"teedoc_plugin_baidu_tongji\": ['assets/*'],\n    },\n```\nSpecify the `assets` directory and all files under it as the package data file to copy to the installation path, and then you can use the relative path (`assets/`) to access in `__init__.py`, which can be accessed in `on_copy_files of `API` Copy this file to the output directory in `, you can see the method of [teedoc_plugin_search](https://github.com/teedoc/teedoc/blob/main/plugins/teedoc-plugin-search/teedoc_plugin_search/__init__.py), in fact Is returning a dictionary\n```python\nself.assets_abs_path = os.path.join(), \"assets\")\n{\n    \"/static/js/search/search_main.js\": os.path.join(os.path.dirname(os.path.abspath(__file__), \"assets\", \"search_main.js\")\n}\n```\nThe keyword is the target path to be copied to, and the value is the absolute path of the file, and then we can refer to it in other `HTML` pages through the path `/static/js/search/search_main.js`\n\n## Test plugin\n\nTwo methods,\n\n### One is to directly let `teedoc` call the source code\n\nIt is recommended to use this method for debugging. Modifying the code only needs to re-execute `teedoc serve` to take effect\n\n* Modify a copy of the `site_config.json` file in the document root directory, and specify the source of the plug-in as the directory path\n```json\n\"plugins\": {\n        \"teedoc-plugin-baidu-tongji\":{\n            \"from\": \"Path\",\n            \"config\": {\n                \"code\": \"9cb07365532534256c346c838181a\"\n            }\n        }\n    },\n```\n\nThen execute `teedoc serve` in the document root directory.\n\n\n### Another way is to install the plug-in directly to the system and let `teedoc` call the package\n\nUsing this method, you need to go through the following steps every time you change the code to modify the code, which is more troublesome than the above method. You can use this method to test the usability before releasing the plug-in.\n\n* Install plugin\n\nAfter the plug-in is written, execute it in the plug-in root directory (the directory with the `setpu.py` file)\n```shell\npip install.\n```\nPay attention to the `.` symbol not to be ignored\n\nThe plugin will be installed to the system as a `python` package\n\n* Then execute `teedoc serve` in the document root directory.\n\n\n## Pay attention\n\nBecause the build will use multiple processes, so there are some places to pay attention to\n\n* Plug-in initialization: `__init__()` function **cannot** be overridden, plug-in initialization can use `on_init()` or `on_new_process_init()`;\n  * `on_init()` is called when the plugin is initialized, and general data can be initialized here. When multiple processes are created, the data of the plug-in will be copied to the new process for use. For some objects that cannot be directly copied by multiple processes, please initialize in `on_new_process_init()`\n  * `on_new_process_init()` is called when multiple processes are created, such as [here](https://github.com/teedoc/teedoc/blob/main/plugins/teedoc-plugin-markdown-parser/teedoc_plugin_markdown_parser/__init__.py) In this function to initialize the `markdown` renderer instead of in the `on_init()`, because you don’t want to copy the `self.md_parser` object when a new process is created, but each new process is rebuilt independently Create an object\n* The same `__del__()` function cannot be used, but use `on_del()` or `on_new_process_del()` function\n* In [plugin.py](https://github.com/teedoc/teedoc/blob/main/teedoc/plugin.py) the functions behind `on_new_process_init()` may be in a new process (multi-process) Called, while the previous function will only be called in the main process\n\n\n## Publish plugin\n\nThe release method of the plug-in is the release method of the ordinary `python` package, published to [pypi.org](https://pypi.org/)\n\n* Execute the command in the root directory of the plug-in to generate the release package:\n\n```shell\npython setup.py bdist_wheel sdist\n```\n\n* Register an account at [pypi.org](https://pypi.org/)\n\n* Then upload to `pypi.org`\n\n```shell\ntwine upload dist/*\n```\n\n* Then users can directly fill in your plugin name in `site_config.json` to use\n\nIt can also be installed via `pip`:\n\n```shell\npip install your plugin name\n```"}, "/develop/en/index.html": {"title": "Develop teedoc", "content": "Develop teedoc\n===========\n\n\n## Get the source code\n\n```\ngit clone https://github.com/Neutree/teedoc\n```\n\n## Installation Environment\n\n```\nsudo apt install python3 python3-pip\ncd teedoc\npip3 install -r requirements.txt\n```\n\n\n\n## Run the source code\n\n* Install plugin\n\n```\npython3 teedoc/teedoc_main.py -p examples/teedoc_site install\n```\n\n* Run\n\n```\npython3 teedoc/teedoc_main.py -p examples/teedoc_site build\npython3 teedoc/teedoc_main.py -p examples/teedoc_site serve\n```\n\n* Plug-in import issues and update debugging issues\n\nSet the local path of the plugin in `site_config.json`, for example:\n```json\n\"teedoc-plugin-markdown-parser\":{\n             \"from\": \"../../plugins/teedoc-plugin-markdown-parser\"\n         }\n```\nThen at runtime, the package will be imported from this path first (add this path to `sys.path` and then import) instead of the system path, which can ensure that the modification takes effect in time\n\n\n\n\n## Debug\n\nTo debug in vscode, you can directly debug the single file `teedoc_debug.py`\n\n## Contribute\n\nYou can `fork` a source code in `github`, after modifying the code, submit `PR`(`pull request`)"}, "/develop/en/no_translate.html": {"title": "no translation", "content": "---\ntitle: no translation\nclass: md_page\n---\n\n\n<div id=\"visit_from\"></div>\n<div id=\"no_translate_hint\">This page not translated yet</div>\n<div>\n    <span id=\"visit_hint\">Please visit</span>\n    <a id=\"translate_src\"></a>\n</div>\n\n<div>\n    <script>\n        function getQueryVariable(variable)\n        {\n            var query = window.location.search.substring(1);\n            var vars = query.split(\"&\");\n            for (var i=0;i<vars.length;i++) {\n                    var pair = vars[i].split(\"=\");\n                    if(pair[0] == variable){return pair[1];}\n            }\n            return(false);\n        }\n        var ref = getQueryVariable(\"ref\");\n        var from = getQueryVariable(\"from\");\n        var link = document.getElementById(\"translate_src\");\n        var fromDis = document.getElementById(\"visit_from\");\n        link.href = ref;\n        link.text = ref;\n        fromDis.innerHTML = from;\n    </script>\n</div>"}}